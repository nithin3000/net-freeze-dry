/* PCAP intialising & interfacing to nRF 51422 using SPI bus
 * 
 * Example extracted from Nordic Semiconductor's SPI master example. All Rights Reserved.
 *
 */

/** @file
* @brief SPI interface to PCAP.
* @defgroup spi_master_example SPI master loopback usage example
* @{
*
* @brief SPI master example.
*
* This example needs that the slave is configured to transmit the received bytes. That is the slave
* behaves as a loopback device for the master. The loopback can also be achieved without using a slave device at all by wiring MOSI and
* MISO pins of the spi master together. @ref TX_RX_MSG_LENGTH number of bytes are transmitted through the master and the received bytes are
* verified to be the same as transmitted. IF there is an error, gpio pin for relevant spi module is set high to show the error @sa ERROR_PIN_SPI0,
* @sa ERROR_PIN_SPI1. If there is error from both modules that is if both pins are set high, then this application loops for ever
*
*/

#include "spi_master.h"
#include "nrf_delay.h"
#include "common.h"
#include "spi_master_config.h"
#include "limits.h"
#include "nRF6350.h"
#include "nrf_gpio.h"
#include "boards.h"
#include "nrf.h"
#include "ant_interface.h"
#include "ant_parameters.h"
#include "nrf_soc.h"
#include "nrf_sdm.h"


#include <string.h>
#include <stdio.h>
#include <math.h>


/***************   PCAP  CONFIGURATION ********************/
/* PCAP config register address definitions ** ask matthew if this is the right intialisation ***/
#define conf_reg0      (0)   
#define conf_reg1      (1)
#define conf_reg2      (2)
#define conf_reg3      (3)
#define conf_reg4      (4)
#define conf_reg5      (5)
#define conf_reg6      (6)
#define conf_reg7      (7)
#define conf_reg8      (8)
#define conf_reg9      (9)
#define conf_reg10      (10)

/*
#define conf_reg11      (11)
#define conf_reg12      (12)
#define conf_reg13      (13)
#define conf_reg14      (14)
#define conf_reg15      (15)
#define conf_reg16	    (16)
#define conf_reg17	    (17)
#define conf_reg18	    (18)
#define conf_reg19	    (19)
#define conf_reg20	    (20)
*/

/* PCAP  read register address definitions ** ask matthew if this is the right intialisation ** */
#define read_reg0      (0)   // C0 LSB
#define read_reg1      (1)	// C1/C0
#define read_reg2      (2)	// C2/C0
#define read_reg3      (3)	// C3/C0
#define read_reg4      (4)	// C4/C0
#define read_reg5      (5)	// C5/C0
#define read_reg6      (6)	// C6/C0
#define read_reg7      (7)	// C7/C0
#define read_stat      (8)	// Status register
#define read_reg8      (11)	// unused
#define read_reg9      (12)	// unused
#define read_reg10      (13) // R0/Rref
#define read_reg11      (14) // R0/Rref

/* Config registration parameters*/
// reconfig all the uint to be of 8 16 32 there is no 24 or 4 or 2

//Register 0 
#define MEMCOMP ((uint8_t) 0) // 0 = disable , 1 = 5 byte , 2 = 33 byte 3 = byte
#define ECC_MODE ((uint8_t) 0x00) // OTP internal error detection and repair 0x00 disable , 0x0F Double, 0xF0 Quad
#define AUTOBOOT_DIS ((uint8_t) 0x0F) // 0xF slave operation, 0x0 stand alone operation
#define MEM_LOCK_DIS ((uint8_t) 0x0F) // OxO activatin the memory read-out blocker 0xF Readoutremain un-blocled 

// Register 2
#define CMEAS_PORT_EN ((uint8_t) 0x3F) // Each bit activates individual PCx ports
#define CMEAS_BITS ((uint8_t) 4) // 1 = grounded cap , 4 =floating single capacitance, 8 = floating differential capacitances
#define RDCHG_INT_SEL ((uint8_t) 6) // 4 = 180 kohm , 5 = 90kohm , 6 = 30 kohm, 7 = 10 kohm

// Register 3
#define CY_CLK_SEL ((uint8_t) 0) // 0 = 20us 2 = 1us 3 = 0.25us 
#define SEQ_TIME ((uint8_t) 0x0D) // 0 = off otherwise s = seq_time  then trig perious will 20us*2^(s+1) 
#define CMEAS_FAKE ((uint8_t) 0) // no of fake block measurements 
#define C_AVRG  ((uint16_t) 1) // Averaging the CDC results
 
// Register 4
#define CMEAS_STARTPIN ((uint8_t) 0) // 0 = PG0, 1 = PG1 , .... 
#define CMEAS_TRIG_SEL ((uint8_t) 2) // 0 = softwaretrigger only , 1 = continuous mode, 2 = timer-triggered mode , 3 = pulse-triggered mode
#define CMEAS_CYTIME ((uint16_t) 0) // CDC cycle time = (CMEAS_CYTIME+1)*clock_period
#define TMEAS_CYTIME ((uint8_t) 0 ) // 0 = 140 us , 1 = 280us
#define TMEAS_STARTPIN ((uint8_t) 0) // 0 = PG0, 1 = PG1 ... pin for pulse triggered temperature measurement.
#define TMEAS_TRIG_SEL ((uint8_t) 0) // trigger source for the temperature measurement 0 = off/opcode triggered , 1 = cmeas-triggered 2 = timer-triggered mode 3= pulse-triggered mode. 

//Register 5
#define T_AVRG ((uint8_t) 0) // 0( 1 = no overaging, 1 (4 fold averaging) , 2 (8-fold averaging) , 3(16-fold averaging) 
#define TMEAS_TRIG_PREDIV ((uint32_t) 0) //zero counts as one, set zero for hygrometers etc 

//Register 6 
#define TMEAS_FAKE ((uint8_t) 0) // 0 = 2 dummy measuremtns,  1 = 8 dummy measurement
#define TMEAS_7BITS ((uint8_t) 0) 

//Register 8 
#define DSP_SRAM_SEL ((uint8_t) 1) // 0 = OTP , 1 = SRAM 
#define DSP_START ((uint8_t) 0) // start command
#define DSP_STARTONOVL ((uint8_t) 0) // 0 = default is mandatory 
#define DSP_STARTONTEMP ((uint8_t) 0) // 0 = default, mandatory with standard fimware 03.01.xx
#define DSP_STARTPIN ((uint8_t) 0) // 0 = PG0, 1 = PG1, 2 = PG2, 3 = PG3
#define DSP_FF_IN ((uint8_t) 0x00) // Bit 12 = PG0 , Bit 13 = PG1, ....
#define DSP_WATCHDOG_LENGTH ((uint8_t) 0) //
#define DSP_MOFLO_EN ((uint8_t) 0) //bit 9 for PG1 bit8 for PG0
#define DSP_SPEED ((uint8_t) 1) // 1 = standard (fast), 3 = low-current (slow)
#define INT2PG2 ((uint8_t) 0) /// interrupt pin reroute to PG2
#define PG1_X_G3 ((uint8_t) 0) //pulse codes reroute from PG1 to PG3
#define PG0_X_G2 ((uint8_t) 0) //pulse codes reroute from PG0 to PG2

//Register 9 
#define PG_DIR_IN ((uint8_t) 0x0F) // toggles outputs to input(PG3/bit23 to PG0/bit 20)
#define PG_PULL_UP ((uint8_t) 0x0F) // Activates pull-up resistor in PG0 to PG3 lines
#define PI_EN ((uint8_t) 0x00) // enables pulse-density or pulse0width mode code generation. PWM0/PDM0 can be output at ports PG0 or PG2. PWM1/PDM1 can be output at ports PG1 or PG3.
#define PI1_CLK_SEL ((uint8_t) 0x00) //Base frequency for the pulse code interfaces based on low-freq or external high-freq oscillator
#define PI0_CLK_SEL ((uint8_t) 0x00)
#define PI1_RES ((uint8_t) 3) // Resolution of pulse code interfaces: 0 = 7 bit, 1 = 8 bit , 2 = 9 bit, 3 = 10 bit.
#define PI0_RES ((uint8_t) 3) // Resolution of pulse code interfaces (see above)

//Register 10 
#define V_CORE_CTL ((uint8_t) 0x47) // 0x87 = Low-current , 0x47 standard 

/********************************************************/


/***************   ANT  CONFIGURATION ********************/
/* ANT Channel Configuration */
#define CHANNEL_0                       ((uint8_t) 0x00)      ///< ANT Channel 0
#define CHANNEL_0_TX_CHANNEL_PERIOD     ((uint16_t)8192)      ///< Channel period 4 Hz
#define CHANNEL_0_ANT_EXT_ASSIGN        ((uint8_t) 0x00)      ///< ANT Ext Assign

/* ANT Channel ID configuration */
#define CHANNEL_0_CHAN_ID_DEV_TYPE      ((uint8_t) 0x02)      ///< Device type 
#define CHANNEL_0_CHAN_ID_DEV_NUM       ((uint8_t) 0x02)      ///< Device number
#define CHANNEL_0_CHAN_ID_TRANS_TYPE    ((uint8_t) 0x01)      ///< Transmission type

/* Misc defines */
#define ANT_CHANNEL_DEFAULT_NETWORK     ((uint8_t) 0x00)      ///< ANT Channel Network
#define ANT_EVENT_MSG_BUFFER_MIN_SIZE   (32)                  ///< Minimum size of ANT event message buffer
#define BROADCAST_DATA_BUFFER_SIZE      (8)                   ///< Size of the broadcast data buffer
#define ANT_OP_ID                     (3) 									///< PCAP register id
#define ANT_MSG_IDX_ID                  (1)                   ///< ANT message id index
/********************************************************/

/***************** OP code defines *********************/
#define START_MEAS 				(1)
#define CHANNEL_COM       (2)
#define PCAP_CONFIG				(3)

/******************************************************/

/* Static variables and buffers */
static uint8_t s_broadcast_data[BROADCAST_DATA_BUFFER_SIZE];  ///< Primary data transmit buffer
//static uint8_t s_counter = 1;                                 ///< Counter to increment the ANT broadcast data payload

static uint32_t cap_t[8]; /* Raw capacitance values */
static uint8_t tx_data[8]; /*!< SPI TX buffer */
static uint8_t rx_data[8]; /*!< SPI RX buffer */
static uint8_t MSG_LEN;
static uint32_t sw = 1, sw2 = 1, stat; 

static uint8_t prgdata[4096] = {0x0, 0x0, 0x0, 0x62, 0x63, 0x0, 0x65, 0xBE, 0x1, 0x20, 0x26, 0x42, 0x5C, 0x48, 0xA0, 0x3, 0x21, 0xE4, 0x20, 0x31, 0xA1, 0x3, 0x21, 0xE4, 0x20, 0x31, 0x84, 0x1, 0x23, 0x63, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0B, 0x43, 0x58, 0xC0, 0xFE, 0x43, 0xC0, 0x44, 0x7A, 0x7E, 0x20, 0x0B, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x43, 0xED, 0x44, 0xC0, 0xC0, 0xC0, 0xF6, 0xFF, 0x43, 0xEC, 0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x41, 0x23, 0x94, 0xD0, 0x43, 0xEE, 0x44, 0xD2, 0x43, 0xEF, 0x44, 0x20, 0x5A, 0x70, 0x60, 0x71, 0x61, 0x78, 0x68, 0x2, 0x7A, 0xF3, 0x43, 0xC7, 0xFE, 0x41, 0xEB, 0x45, 0x5A, 0x21, 0xDF, 0x46, 0x46, 0x46, 0x46, 0xEC, 0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x43, 0x55, 0xED, 0x45, 0xEC, 0x51, 0xF4, 0x41, 0x23, 0x88, 0xEA, 0x45, 0xF5, 0x41, 0x23, 0x88 , 0xE9, 0x45, 0x1D, 0x41, 0x43, 0x58, 0xEA, 0x21, 0x99, 0xE9, 0x50, 0x46, 0xEB, 0x44, 0xA9, 0x2, 0xEB, 0x59, 0x43, 0xCA, 0xFE, 0x41, 0x5C, 0xA8, 0x3, 0xC0, 0x5A, 0xEB, 0x45, 0xEB, 0x41, 0xF2, 0x45, 0xF6, 0x41, 0x23, 0x88, 0xEA, 0x45, 0xF7, 0x41, 0x23, 0x88, 0xE9, 0x45, 0x1F, 0x41, 0x43, 0x58, 0xEA, 0x21, 0x99, 0xE9, 0x50, 0x46, 0xEB, 0x44, 0xA9, 0x2, 0xEB, 0x59, 0x43, 0xCA, 0xFE, 0x41, 0x5C, 0xA8, 0x3, 0xC0, 0x5A, 0xEB, 0x45, 0xEB, 0x41, 0xF3, 0x45, 0x2, 0xFF, 0xFF, 0xFF, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x7C, 0x7D, 0x45, 0x41, 0x2, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0xF0, 0x7C, 0x6D, 0x45, 0x41, 0x6C, 0x7D, 0x45, 0x41, 0x2, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0xF0, 0x6C, 0x7D, 0x45, 0x41, 0x2, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0xF0, 0x7C, 0x6D, 0x45, 0x41, 0x45, 0x41, 0x2, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0xF0, 0x7C, 0x6D, 0x45, 0x41, 0x2, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x2, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x2, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x2, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x2, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x2, 0x6A, 0xFD, 0x43, 0x40, 0x4F, 0x4F, 0x4F, 0xEB, 0x45, 0x7A, 0xF9, 0x41, 0x43, 0x58, 0xEB, 0x21, 0x99, 0xEA, 0x44, 0xC0, 0xC0, 0xC0, 0xF1, 0xFF, 0x43, 0xEC, 0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x41, 0xED, 0x45, 0xC0, 0x41, 0xC0, 0xC0, 0xC0, 0xF8, 0xFF, 0x43, 0xE9, 0x44, 0x6A, 0x1D, 0x43, 0xAB, 0x1, 0xEA, 0x58, 0x8E, 0x3, 0xEC, 0x53, 0x1D, 0x50, 0x1F, 0x44, 0xEC, 0x53, 0xED, 0x53, 0xE9, 0x43, 0xEC, 0x58, 0xAC, 0xE6, 0x8E, 0x26, 0xC0, 0xC0, 0xC0, 0xF9, 0xFF, 0x43, 0xEC, 0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x43, 0xED, 0x44, 0xC0, 0x41, 0xC0, 0xC0, 0xC0, 0xFC, 0xFF, 0x43, 0xE9, 0x44, 0x1D, 0x43, 0x1F, 0x59, 0xE9, 0x43, 0xED, 0x53, 0xEC, 0x53, 0x58, 0xAC, 0xF2, 0x7A, 0xC0, 0xC0, 0xC0, 0xC9, 0xFF, 0x43, 0xEC, 0x44, 0xE7, 0x44, 0xE8, 0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x43, 0xED, 0x44, 0x1F, 0x43, 0x4E, 0x4E, 0x4E, 0x44, 0xC0, 0xC0, 0xC0, 0xCF, 0xFF, 0x43, 0xE9, 0x44, 0x8E, 0x7, 0xC0, 0xC0, 0xC0, 0xCB, 0xFF, 0x43, 0xE9, 0x44, 0x40, 0x5D, 0x1D, 0x43, 0x1F, 0x21, 0xCA, 0xE8, 0x43, 0xEC, 0x44, 0x1D, 0x45, 0xF8, 0x43, 0xAB, 0x0C, 0xC0, 0x41, 0xED, 0x53, 0x53, 0x1F, 0x43, 0x4E, 0x4E, 0x4E, 0x44, 0xE7, 0x53, 0xC0, 0x41, 0xE8, 0x53, 0xE7, 0x53, 0x41, 0xEC, 0x45, 0xE9, 0x43, 0x5C, 0xAC, 0xD3, 0xC0, 0xC0, 0xC0, 0xCF, 0xFF, 0x43, 0xE9, 0x44, 0xE8, 0x41, 0xE9, 0x43, 0x5C, 0xA8, 0x0C, 0xC0, 0x41, 0xE8, 0x43, 0x53, 0xEC, 0x44, 0x1D, 0x44, 0x59, 0x43, 0xAB, 0xEB, 0xC8, 0x43, 0x46, 0x46, 0x46, 0x44, 0x7A, 0x8A, 0x1B, 0xC0, 0x43, 0x40, 0x5D, 0x5D, 0x90, 0x15, 0xC8, 0x45, 0xC9, 0x45, 0xF8, 0x43, 0xAA, 0x0B, 0xCA, 0x45, 0xCB, 0x45, 0xCC, 0x45, 0xCD, 0x45, 0xCE, 0x45, 0xCF, 0x45, 0x0, 0x2, 0xC0, 0x43, 0x4E, 0x4E, 0xEA, 0x44, 0xE9, 0x44, 0x8E, 0x6, 0xC0, 0x43, 0x4E, 0xEA, 0x44, 0xE9, 0x44, 0xF8, 0x43, 0xAB, 0x13, 0xC0, 0x43, 0x4E, 0xEA, 0x44, 0x4E, 0x50, 0xE9, 0x44, 0x8E, 0x8, 0xC0, 0x43, 0xEA, 0x44, 0x4E, 0x4E, 0x50, 0xE9, 0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x43, 0x4E, 0x4E, 0xE9, 0x51, 0x91, 0x1, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x92, 0x1, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x93, 0x1, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x94, 0x1, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x95, 0x1, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x96, 0x1, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x97, 0x1, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x2, 0xE9, 0x43, 0x46, 0x46, 0xEC, 0x44, 0x1D, 0x45, 0x2, 0x7A, 0xFA, 0x41, 0x4F, 0x4F, 0x4F, 0xE7, 0x45, 0x5A, 0xFB, 0x43, 0xE7, 0x75, 0x21, 0xCA, 0x65, 0xD0, 0x45, 0x5A, 0xFC, 0x43, 0xE7, 0x21, 0xCA, 0xD1, 0x45, 0x5A, 0xFD, 0x43, 0xE7, 0x21, 0xCA, 0xD2, 0x45, 0x79, 0x69, 0x2, 0xD7, 0xFE, 0x43, 0xE7, 0x45, 0x5D, 0xAD, 0x1, 0x5D, 0x45, 0x41, 0x2, 0x1F, 0x43, 0x1D, 0x44, 0xC0, 0x43, 0xEC, 0x51, 0xED, 0x51, 0x5D, 0xAA, 0xF2, 0x2, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2, 0x1, 0x3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 


#define DELAY_MS               100        /*!< Timer Delay in milli-seconds */
#define BUTTON2        					 2
#define ERR_LED        					 8
#define LED6        					   14

/** 
 * @brief Handle error from application
 */
static void handle_error(void)
{
    /* Error */
    while (1) 
    {
    }
}

/**
 * @brief Setup ANT module ready for TX broadcast.
 *
 * Issues the following commands in a specific order:
 * - assign channel
 * - set channel ID   
 * - open channel 
 */
static void ant_channel_tx_broadcast_setup(void)
{
    uint32_t return_value;
    
    /* Set Channel Number */
    return_value = sd_ant_channel_assign(CHANNEL_0, 
                                      CHANNEL_TYPE_MASTER, 
                                      ANT_CHANNEL_DEFAULT_NETWORK, 
                                      CHANNEL_0_ANT_EXT_ASSIGN);
    if (return_value != NRF_SUCCESS)
    {
        /* Error */
        handle_error();
    }

    /* Set Channel ID */
    return_value = sd_ant_channel_id_set(CHANNEL_0, 
                                      CHANNEL_0_CHAN_ID_DEV_NUM, 
                                      CHANNEL_0_CHAN_ID_DEV_TYPE, 
                                      CHANNEL_0_CHAN_ID_TRANS_TYPE);
    if (return_value != NRF_SUCCESS)
    {
        handle_error();
    }

    /* Open Channel */
		/*Modify this in the future to close & open channel */
    return_value = sd_ant_channel_open(CHANNEL_0);
    if (return_value != NRF_SUCCESS)
    {
        handle_error();
    }
}



/** 
 * @brief Stack Interrupt handler 
 *
 * Implemented to clear the pending flag when receiving 
 * an interrupt from the stack.
 */
void PROTOCOL_EVENT_IRQHandler(void)
{
}

/**
 * @brief Handle softdevice asserts 
 *
 * @param[in] pc is the value of the program counter
 * @param[in] line_num is the line number which the assert occured
 * @param[in] p_file_name is the gile name of the file that it asserted
 *
 */
void softdevice_assert_callback(uint32_t pc, uint16_t line_num, const uint8_t * p_file_name)
{
    while (1)
    {
        /* No implementation needed. */
    }
}

/**
 * @brief Handle HardFault
 */
void HardFault_Handler(void)
{
    while (1)
    {
      /* No implementation needed. */
    }
}

/***** Bit Packing function to generate 32 bit function ****
 * @param a, b, c, d, e : Variables containing the bits to be combined
 * @param nb, nc, nd, ne : Position of the bits to be combined
 * @retval p 32bit integer to be returned
 */

uint32_t pack(uint32_t a, uint32_t b, uint8_t nb, uint32_t c, uint8_t nc, uint32_t d, uint8_t nd, uint32_t e, uint8_t ne)
	{
		uint32_t p = a;
		p = (p << nb)| b ;
		p = (p << nc)| c ;
		p = (p << nd)| d ;
		p = (p << ne)| e ;
		return p;
	}

/** Sets SPI interface.
 * @param lsb_first If true, least significant bits are transferred first
 * @param mod_num spi module to be used, either SPI0 or SPI1 from enumeration SPIModuleNumber
 * @retval Pointer to SPIaddress 
 * @retval false Error occurred
 * PCAP settings : 
 * 				@SPImode 1 , @BITsequence , MSB first 
 */
 uint32_t* pcap_spi_set(SPIModuleNumber mod_num)
{
  uint32_t *PCAP_spi_address = spi_master_init(mod_num, SPI_MODE1, (bool) 0);

  return PCAP_spi_address;
}

/***** Transmits/Recieves data using SPI. ****
 * @param PCAP_spi_address Pointer containing the set spi address 
 * @param MSG_LEN length of the message to be transmitted
 * @param tx_data pointer containing the transmitted data
 * @param rx_data pointer containing the recieved data
 * @retval True 
 * @retval false Error occurred
 */
bool pcap_spi_tx_rx(uint32_t *PCAP_spi_address, uint8_t MSG_LEN, uint8_t *tx_data)
{
	bool PCAP_spi_chk = spi_master_tx_rx(PCAP_spi_address, MSG_LEN, (const uint8_t *)tx_data, (uint8_t *)rx_data);
  
  if (PCAP_spi_chk)
    return true;
	else 
		return false;
}
/**** PCAP DSP SPI write function ****
* @param PCAP_spi_address:  SPI address set by the SPI Set function 
* @retval false for unsucessful set
*/
bool pcap_dsp_write(uint32_t *PCAP_spi_address) 
{
	//uint8_t prgdata[4096];
	uint16_t regadd = 0;
	uint16_t x;
	uint8_t y;
	bool b;
	uint32_t p;
	MSG_LEN = 4;

	//standard measurement DSP file 
	//ANT chip crashes need better implementation.
		for (x = 0; x < 4096; x++)
			{
				regadd = x;									
				p = 0x09;      // Add SRAM write code
				p = (p << 12)|regadd;   // add SRAM Address 
				p = (p << 8)|prgdata[x];  // add program data
				
				// segmentation of into 3 segments of 8 bit variables and add to data packet
				for (y = 0; y < (3); y++)
					{
						tx_data[y] = (p >> ((2)-y)*CHAR_BIT)&(0xFF);
					}
				b = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data); // test submission
				memset(tx_data, 0, 8);
				memset(rx_data, 0, 8);
				
			}
			return b;
}
/**** PCAP config register SPI write function ***
* @param PCAP_spi_address:  SPI address set by the SPI Set function 
* @param regdata: Array of 24 bit data containing the register values in sequential order from (0-9)
* @retval false for unsucessful set
*/
	
bool pcap_config_write(uint32_t *PCAP_spi_address, uint32_t *regdata) // why does the pointer work here
	{
		//Variable declaration & initialisation 
		// uint8_t n = 0;
		uint8_t regadd = 0;
	  uint8_t x, y;
		uint32_t p;
		bool b;	
		
		MSG_LEN = 4;

		/*run bit configuration (register 20) */ 
		/* set run bit   = 0 for configuration set*/
		
		p = 0x03; // Add write code
		p = (p << 6)|20; // add Address 
		p = (p << 24)|(0); // add data
		for (y = 0; y < (4); y++)
			{
				tx_data[y] = (p >> ((3)-y)*CHAR_BIT) & (0xFF) ;
			}
		b = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data);

		/* Configuration registers (Registers 0-19) write loop */
		for (x = 0; x < 20; x++)
			{
				regadd = x;									
				p = 0x03;      // Add write code
				p = (p << 6)|regadd;   // add Address 
				p = (p << 24)|regdata[x];  // add data
				
				// segmentation of into 8 bit variables and add to data packet
				for (y = 0; y < (4); y++)
					{
						tx_data[y] = (p >> ((3)-y)*CHAR_BIT)&(0xFF) ;
					}
				b = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data); // test submission
				// need to implement check function 
				//b = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data);
				//nrf_delay_ms(DELAY_MS);	
				memset(tx_data, 0, 8);
				memset(rx_data, 0, 8);
				//n = n + 4; // next segmentation incremetn
			}
			nrf_delay_ms(DELAY_MS);	
			//run bit confiuration i.e register 20
			p = 0x03; // Add write code
			p = (p << 6)|20; // add Address 
			p = (p << 24)|(1); // add data
			for (y = 0; y < (4); y++)
				{
					tx_data[y] = (p >> ((3)-y)*CHAR_BIT) & (0xFF) ;
					b = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data);
				}
		b = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data);
		//nrf_delay_ms(DELAY_MS);	
		// need to implement check function 
		return b;
	}
	
/**** PCAP config register set function ***
	* @PCAP_spi_address:  SPI address set by the SPI Set function 
  * Sets the indivual configuration registers and send it to the PCAP_config_write function for SPI write.
	* Return false for unsucessful set
*/
bool config_reg_set(uint32_t *PCAP_spi_address) 
	{ 
		uint32_t config_reg_d[20];
		uint8_t DSP_PRESET, PG_PRESET;
		bool w; 
		
		/* register 0 */
		config_reg_d[0] = pack((0x04), (MEMCOMP << 2)|2, 4, ECC_MODE, 8, AUTOBOOT_DIS, 4, MEM_LOCK_DIS,4);
				
		/* register 1 */
		config_reg_d[1] = 0x201022;
		
		/* register 2 */
		config_reg_d[2] = pack(CMEAS_PORT_EN, CMEAS_BITS, 4, RDCHG_INT_SEL, 4, 0x0B, 8, 0, 0);
		
		/* register 3 */
		config_reg_d[3] = pack(CY_CLK_SEL, SEQ_TIME, 6, CMEAS_FAKE, 3, C_AVRG, 13 , 0, 0);
		
		/* register 4 */
		config_reg_d[4] = pack(CMEAS_STARTPIN, CMEAS_TRIG_SEL, 2, CMEAS_CYTIME, 10, TMEAS_CYTIME, 4, ((TMEAS_STARTPIN << 2)|TMEAS_TRIG_SEL), 4);
		
		/* register 5 */
		config_reg_d[5] = pack(T_AVRG, TMEAS_TRIG_PREDIV, 22, 0, 0, 0, 0, 0 ,0);
		//config_reg_d[5] = 0x000000
			
		/* register 6 */
		config_reg_d[6] = pack(0, TMEAS_FAKE, 1, TMEAS_7BITS, 7, 0x40, 8, 0, 0);
		//config_reg_d[6] = 0x000040 ;
		
		/* register 7 */
		config_reg_d[7] = 0x1F0000 ;
		
		/* register 8 */
		DSP_PRESET = pack(DSP_SRAM_SEL, DSP_START, 1, DSP_STARTONOVL, 1, DSP_STARTONTEMP, 1, DSP_STARTPIN, 4);
		PG_PRESET = pack(INT2PG2, PG1_X_G3, 1, PG0_X_G2, 1, 0, 0, 0, 0);
		
		config_reg_d[8] = pack(DSP_PRESET, DSP_FF_IN, 4, (DSP_WATCHDOG_LENGTH << 2)|DSP_MOFLO_EN, 4, DSP_SPEED, 4, PG_PRESET, 4);
		//config_reg_d[8] = 0x800030 ;
		
		/* register 9 */
		config_reg_d[9] = pack(PG_DIR_IN, PG_PULL_UP, 4, PI_EN, 4, (PI1_CLK_SEL << 4)| PI0_CLK_SEL, 8, (PI1_RES << 2) | PI0_RES, 4); 
		//config_reg_d[9] = 0xFF000F ; 
		
		/* register 10 */
		config_reg_d[10] = pack(0x18, 00, 8, V_CORE_CTL, 8,0,0,0,0);
		//config_reg_d[10] = 0x180087;
		
		/* param register 11 */
		config_reg_d[11] = 0x000000 ;
		
		/* param register 12 */
		config_reg_d[12] = 0x000000 ;
		
		/* param register 13*/
		config_reg_d[13] = 0x000000 ;
		
		/* param register 14*/
		config_reg_d[14] = 0x000000 ;
		
		/* param register 15*/
		config_reg_d[15] = 0x000000 ;

		/* param register 16*/
		config_reg_d[16] = 0x000000 ;
		
		/* param register 17*/
		config_reg_d[17] = 0x000000 ;
		
		/* param register 18*/
		config_reg_d[18] = 0x000000 ;
		
		/* param register 19*/
		config_reg_d[19] = 0x200000 ; //gain correction register 
				
		w = pcap_config_write(PCAP_spi_address, config_reg_d);
		return w;
	}

	
/**** PCAP read register set function ***
	* Speifies the register to be read and send the command to the PCAP sensor
	* @param PCAP_spi_address:  SPI address set by the SPI Set function 
  * @param read register address see definition list fore register address
	* @retval Return false for unsucessful set or read
	* @retval Return register data for succesful set
*/

uint32_t read_reg(uint32_t *PCAP_spi_address, uint8_t wr_reg_add) 
	{ 
		bool meas;
		uint32_t rx_reg_data;
		uint8_t p;
		
		MSG_LEN = 4; //Length of message to be transmitted
	
		// Read Register address 
		p = 0x01;      // Read code
		p = (p << 6)|wr_reg_add;   // Address 
		tx_data[0] = p; 
		
		nrf_delay_ms(DELAY_MS);
		meas = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data); //Intiate the read of capacitance data
	  	
		rx_reg_data = pack(rx_data[1], rx_data[2], 8, rx_data[3], 8, 0, 0, 0, 0 );
			
		//Return capacitance data
		if (meas == 0)
			return meas;
		else
			return rx_reg_data;
	}
	
	
/**** PCAP broadcast data prep function ***
	* Send read register data for ANT broadcast
	* @param add: Address/identifier to identify sent data
	* @param data: Data to be sent
	* @retval none
*/

static void pcap_broadcast_data(uint8_t add, uint32_t data)
	{
		s_broadcast_data[0] = add;
		for (uint8_t y = 1; y < (4); y++)
		{
			s_broadcast_data[y] = (data >> ((3)-y)*CHAR_BIT) & (0xFF) ;
		}
	}

/**** PCAP data extraction function ***
	* Extract the recieved read register data and converts it to decimal nature
	* @param data: data obtained from the read register 
	* @retval ext capacitance data for succesful set
*/
	
float data_extract(uint32_t data)
{
	//int p = (data >> 21) & 7;
	//uint32_t d = data & 0x1FFFFF;
	//float ext = (float) p + (float)(d/10000000);
	float p = data;
	float ext= p/(pow(2,21));
	return ext;
}
		



/** 
 * @brief Handle ANT TX channel events 
 *
 * @param[in] event is the received ant event to handle
 *
 */
static void handle_channel_event(uint32_t event, uint8_t add, uint32_t data, uint8_t * p_event_message_buffer)          
{
    uint32_t return_value;
    //uint32_t p;
	
    switch (event)
    {
        /* Ant broadcast success.
         * Send a new broadcast and increment the counter 
         */
        case EVENT_TRANSFER_TX_COMPLETED:
            
						/* Prep broad cast data for transmit */
						pcap_broadcast_data(add, data);
            
            /* Broadcast the data */
            return_value = sd_ant_acknowledge_message_tx(CHANNEL_0, BROADCAST_DATA_BUFFER_SIZE, s_broadcast_data);
            if (return_value != NRF_SUCCESS)
            {
                /* Error */
                handle_error();
            }
            //nrf_delay_ms(500);                       
            
						/* Activate LED0 for 20 ms */
            nrf_gpio_pin_set(ERR_LED);
            nrf_delay_ms(20);
            nrf_gpio_pin_clear(ERR_LED);
            break;
				case EVENT_RX: 
					switch (p_event_message_buffer[ANT_MSG_IDX_ID])
					{
						/* Acknowledged data recieved */
						//case MESG_BROADCAST_DATA_ID:  
						case MESG_ACKNOWLEDGED_DATA_ID:   //Necessary to check acknowledged data in embedded systems 
								/* Activate LED for 20 ms */
								nrf_gpio_pin_set(ERR_LED);
								nrf_delay_ms(100);
								nrf_gpio_pin_clear(ERR_LED);
								//p = pack(p_event_message_buffer[4], p_event_message_buffer[5], 8, p_event_message_buffer[6], 8, 0, 0, 0, 0);
								
								switch (p_event_message_buffer[ANT_OP_ID])
										{
												case START_MEAS:
														sw = 0 ;
														break;
												case CHANNEL_COM:
														break;
												case PCAP_CONFIG:
														break;
												default:
														break;
										}
								break;
					}
        default:      
            break;
    }
}






/**
 * main() function
 * @return 0. int return type required by ANSI/ISO standard. 
 */
int main(void)
{
  // Variable declarations 
	bool ret0, ret1, ret2, ret3; // error checkers
	uint8_t CYC_ACTIVE, T_END_FLAG, RUNBIT, COMBI_ERR, CAP_ERR, CAP_ERR_PC, TEMP_ERR; // Status register error checkers
	//uint32_t  capref_t;
	uint8_t x, n;
	
	//uint32_t* PCAP_spi_address;
	//char capref_s[16]; // String displays for LCD
	//char cap1_s[7][16]; 
	//float cap1, cap2, cap3, cap4, cap5, cap6, cap7, capref;
	
	uint8_t  event;
  uint8_t  ant_channel;    
  uint32_t return_value;
 
  /* ANT event message buffer */
  static uint8_t event_message_buffer[ANT_EVENT_MSG_BUFFER_MIN_SIZE];
	
		
	/* Clearing Error pins */
	//NRF_GPIO->DIRSET = (1UL << ERROR_PIN_SPI0);
	//NRF_GPIO->DIRSET = (1UL << ERROR_PIN_SPI1);
	nrf_gpio_range_cfg_output(LED_START, LED_STOP);
	
	/* Indicate application is Running */
	//NRF_GPIO->OUTSET = (1 << LED6) | (1 << LED7);
	
	/* Enable softdevice */
  return_value = sd_softdevice_enable(NRF_CLOCK_LFCLKSRC_XTAL_250_PPM, softdevice_assert_callback);
  if (return_value != NRF_SUCCESS)
	{
			/* Error */
			handle_error();
	}

  /* Set application IRQ to lowest priority */
  return_value = sd_nvic_SetPriority(PROTOCOL_EVENT_IRQn, NRF_APP_PRIORITY_LOW); 
	if (return_value != NRF_SUCCESS)
	{
			/* Error */
			handle_error();
	}
  
	/* Enable application IRQ (triggered from protocol) */
	return_value = sd_nvic_EnableIRQ(PROTOCOL_EVENT_IRQn);      
	if (return_value != NRF_SUCCESS)
	{
			/* Error */
			handle_error();
	}
   
	/* Setup Channel_0 as a TX-RX Master Only */
  /*Modify this in the future to close & open channel */
  ant_channel_tx_broadcast_setup();
  	
	// Intialise and check and LCD initalisation
// 	if(!nrf6350_lcd_init())
// 	{
// 		// LED0 for LCD intialisation error
// 		NRF_GPIO->OUTSET = (1UL << ERROR_PIN_SPI0);
// 	}
// 	nrf6350_lcd_clear();
// 	nrf6350_lcd_write_string("Press Button 0", 16, LCD_UPPER_LINE, 0);

  /* SPI Intialisation */ 
	uint32_t *PCAP_spi_address = pcap_spi_set(SPI1);

	if (PCAP_spi_address == 0)
	{
		// Error LED = 1
		NRF_GPIO->OUTSET = (1UL << ERR_LED);
		
	}
	pcap_dsp_write(PCAP_spi_address);


	/* Main Loop */
	while(true)
	{
		/* Intialisation of Switch variables */
		sw = 1;
		sw2 = 1;
				
		/* Configuring Button 0 as input */
		//nrf_gpio_cfg_input(BUTTON0, NRF_GPIO_PIN_NOPULL);
		//sw = nrf_gpio_pin_read(BUTTON0); // 0 indicates button pressed & 1 indicates button releas
		
		/* Recieve Transmission input */
		/* Fetch the event */
    return_value = sd_ant_event_get(&ant_channel, &event, event_message_buffer);
		if (return_value == NRF_SUCCESS)
		{
			/* Handle event */
			switch (event)
			{
					case EVENT_RX:
							handle_channel_event(event, 0, 0, event_message_buffer);
							break;
					default:
							break;
			}
		}
		/* Put CPU in sleep if possible */
		return_value = sd_app_event_wait();
		while(sw == 0)
		{
			
			/* SPI Intialisation 
			uint32_t *PCAP_spi_address = pcap_spi_set(SPI1);

			if (PCAP_spi_address == 0)
			{
				// Error LED = 1
				NRF_GPIO->OUTSET = (1UL << ERROR_PIN_SPI1);
				
			}*/
			
			/* SPI communication check */
			MSG_LEN = 8;
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			tx_data[0] = 0x10;  
			tx_data[1] = 0x08;
			
			ret1 = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data);
			nrf_delay_ms(DELAY_MS);
			
			/* Set configuration registers */
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			ret0 = config_reg_set(PCAP_spi_address);
			
			if (ret0 == 0)
			{
				//Error LED = 2 for config check
				NRF_GPIO->OUTSET = (1UL << ERR_LED);
			}
			
			/* Send a partial reset */
			MSG_LEN = 8;
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			tx_data[0] = 0x8A; // Partial Reset 
			
			nrf_delay_ms(DELAY_MS);
			ret1 = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data);
			if (ret1 == 0)
			{
				//Error LED = 3 for Reset Check
				NRF_GPIO->OUTSET = (1UL << ERR_LED);
			}
			
			/* Start Capacitance Measurement */
			MSG_LEN = 8;
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			tx_data[0] = 0x8C; // Start Command 
			
			nrf_delay_ms(DELAY_MS);
			ret2 = pcap_spi_tx_rx(PCAP_spi_address, MSG_LEN, tx_data);
			if (ret2 == 0)
			{
				//Error LED = 4 for Measurement Start
				NRF_GPIO->OUTSET = (1UL << ERR_LED);
			}
			
			/* Measurement Delay */
			nrf_delay_ms(1000);
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
		
			/* Read Status register: */
			stat = read_reg(PCAP_spi_address, read_stat);
			
			/* Prep broad cast data for transmit */
			pcap_broadcast_data(read_stat, stat);
			
			/* First Broadcast */
			/* Initiate the broadcast loop by sending a packet on air, 
			* then start waiting for an event on this broadcast message
			*/
		
			
			/* Read cap values: */
			
			/* Reference Capacitor */
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			cap_t[0] = read_reg(PCAP_spi_address, read_reg0);
			
			/* Measured Capacitors */
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			cap_t[1] = read_reg(PCAP_spi_address, read_reg1);
			
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			cap_t[2] = read_reg(PCAP_spi_address, read_reg2);
			
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			cap_t[3] = read_reg(PCAP_spi_address, read_reg3);
			
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			cap_t[4] = read_reg(PCAP_spi_address, read_reg4);
			
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			cap_t[5] = read_reg(PCAP_spi_address, read_reg5);
			
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			cap_t[6] = read_reg(PCAP_spi_address, read_reg6);
			
			memset(tx_data, 0, 8);
			memset(rx_data, 0, 8);
			cap_t[7] = read_reg(PCAP_spi_address, read_reg7);
									
			
			ret3 = (stat == 0 && cap_t == 0 && cap_t[1] == 0); 
			if (stat == 0) // if (ret3 == 0)
			{
				// Error LED = 5 for Status 
				NRF_GPIO->OUTSET = (1UL << ERR_LED);
			}
			
			if (cap_t[1] == 0)
			{
				// Error LED = 6 for Measurement Check
				NRF_GPIO->OUTSET = (1UL << ERR_LED);
			}
			
			/* Complete error checker */
			
			if (!ret0 && !ret1 && !ret2 && !ret3 && !PCAP_spi_address)
			{
				while(true)
				{
						// Loop forever
					//nrf6350_lcd_write_string("Error", 16, LCD_UPPER_LINE, 0);
				}
			}
			
// 			if (!ret0 || !ret1 || !ret2 || !ret3 || !PCAP_spi_address)
// 			{
// 				while(true)
// 				{
// 						// Loop forever
// 					nrf6350_lcd_write_string("Error", 16, LCD_UPPER_LINE, 0);
// 				}
// 			}
			
			/* Status bits */ 
			//configure later for further analysis 
			CYC_ACTIVE = (stat >> 23) & 1;
			T_END_FLAG = (stat >> 22) & 1;
			RUNBIT = (stat >> 19) & 1;
			COMBI_ERR = (stat >> 15) & 1;
			CAP_ERR = (stat >> 12) & 1;
			CAP_ERR_PC = (stat >> 5) & 0x0F;
			TEMP_ERR = (stat >> 3) & 1;
			
			/* Data extraction: */
			//capref = data_extract(cap_t[0])*47 ;
			//capref = 5;
			
			/* Data display on LCD */
			//sprintf(capref_s, "Cref = %f", capref);
			
			/* Light up LED7 to indicate that CPU is going to sleep */
			//nrf_gpio_pin_set(LED7);
			
			/* Put CPU in sleep if possible */
			return_value = sd_app_event_wait();
			if (return_value != NRF_SUCCESS)
			{
					/* Error */
					handle_error();
			}
			
			/* Turn off LED7 to indicate that CPU is going out of sleep */
			//nrf_gpio_pin_clear(LED7);
			
			return_value = sd_ant_acknowledge_message_tx(CHANNEL_0, BROADCAST_DATA_BUFFER_SIZE, s_broadcast_data);
			//return_value = sd_ant_event_get(&ant_channel, &event, event_message_buffer);

			if (return_value != NRF_SUCCESS)
			{
					/* Error */
					handle_error();
			}								


			/* Extract and process all pending ANT events as 
         * long as there are any left. */      
			do
			{
					/* Fetch the event */
					return_value = sd_ant_event_get(&ant_channel, &event, event_message_buffer);
					if (return_value == NRF_SUCCESS) 
					{
							/* Handle event */
							switch (event)
							{
								case EVENT_TX:	// Needed to sucessfully acknowledge all the recieved bits
								case EVENT_TRANSFER_TX_COMPLETED:
											//handle_channel_event(event);
											//break;
										x = 0;
										
										/* Find which configuration the system has been setup
										i.e Floating or Grounded mode */
										switch(CMEAS_BITS)
										{
											case 1: // grounded
												n = 1;
												do
												{
													sd_ant_event_get(&ant_channel, &event, event_message_buffer);
													uint16_t chk = (CMEAS_PORT_EN >> n) & 0x01;
												
													/* Check for transmission and no of capacitors to be read*/
													if(chk == 1 && event == EVENT_TRANSFER_TX_COMPLETED) 
													{
														switch (n)
														{
															case 1:
															//cap1 = data_extract(cap_t[1])*47;
															handle_channel_event(event, read_reg1, cap_t[1], event_message_buffer);
															//sprintf(cap1_s[x], "Cap1 = %f ", cap1);
															x++;
															break;
															
															case 2:
															//cap2 = data_extract(cap_t[2])*47;
															handle_channel_event(event, read_reg2, cap_t[2], event_message_buffer);
															//sprintf(cap1_s[x], "Cap2 = %f ", cap2);
															x++;
															break;
															
															case 3:
															//cap3 = data_extract(cap_t[3])*47;
															handle_channel_event(event, read_reg3, cap_t[3], event_message_buffer);
															//sprintf(cap1_s[x], "Cap3 = %f ", cap3);
															x++;
															break;							
															
															case 4:
															//cap4 = data_extract(cap_t[4])*47;
															handle_channel_event(event, read_reg4, cap_t[4], event_message_buffer);
															//sprintf(cap1_s[x], "Cap4 = %f ", cap4);
															x++;
															break;
															
															case 5:
															//cap5 = data_extract(cap_t[5])*47;
															handle_channel_event(event, read_reg5, cap_t[5], event_message_buffer);
															//sprintf(cap1_s[x], "Cap5 = %f ", cap5);
															x++;
															break;		
																
															case 6:
															//cap6 = data_extract(cap_t[6])*47;
															handle_channel_event(event, read_reg6, cap_t[6], event_message_buffer);
															//sprintf(cap1_s[x], "Cap6 = %f ", cap6);
															x++;
															break;
															
															case 7:
															//cap7 = data_extract(cap_t[7])*47;
															handle_channel_event(event, read_reg7, cap_t[7], event_message_buffer);
															//sprintf(cap1_s[x], "Cap7 = %f ", cap7);
															x++;
															break;
															
														}								
													}
													if(event != EVENT_TRANSFER_TX_COMPLETED && chk == 1)
													{
														/* Soft exit from loop in case transmit event hasn't completed 
														chk function necessary to ensure that capacitors are transmitted and prevent infinite looping*/
														continue;
													}
												}while(n < 7);
												
												/* Flag to ensure all capacitors values have been transmitted*/
												sw2 = 0;
												break;
											case 4: // floating
												n = 1;
												do
												{
													sd_ant_event_get(&ant_channel, &event, event_message_buffer);
													uint16_t chk = (CMEAS_PORT_EN >> 2*n) & 0x03;
													//x = 0;
													
													/* Check for transmission and no of capacitors to be read*/
													if(chk == 3 && event == EVENT_TRANSFER_TX_COMPLETED) 
													{
														switch (n)
														{
															case 1:
															//cap1 = data_extract(cap_t[1])*47;
															handle_channel_event(event, read_reg1, cap_t[1], event_message_buffer);
															//sprintf(cap1_s[x], "Cap1 = %f ", cap1);
															x++;
															break;
															
															case 2:
															//cap2 = data_extract(cap_t[2])*47;
															handle_channel_event(event, read_reg2, cap_t[2], event_message_buffer);
															//sprintf(cap1_s[x], "Cap2 = %f ", cap2);
															x++;
															break;
															
															case 3:
															//cap3 = data_extract(cap_t[3])*47;
															handle_channel_event(event, read_reg3, cap_t[3], event_message_buffer);
															//sprintf(cap1_s[x], "Cap3 = %f ", cap3);
															x++;
															break;							
														}								
													}
													if(event != EVENT_TRANSFER_TX_COMPLETED && chk == 3) 
													{
														/* Soft exit from loop in case transmit event hasn't completed 
														chk function necessary to ensure that capacitors are transmitted and prevent infinite looping*/
														
														continue;
													}
													n++;
												} while(n < 4);
												/* Flag to ensure all capacitors values have been transmitted*/
												sw2 = 0;
												break;
										}
											break;
									default:
										break;
							}					         	
					}	
			/* No else clause needed for empty queue handler. */
			} while (return_value == NRF_SUCCESS & sw2!= 0);
			
			n = 0;		
//      sw2 = 0;		
//      sw3 = 1;		
      /* LCD display loop */			
// 			while(sw3 == 1)		
// 			{
// 				/* Read Button2 to indicate loop exit */
// 				sw3 = nrf_gpio_pin_read(BUTTON2);
// 				
// 				if (sw2 == 0)
// 				{	
// 					/* Display the capacitance data */
// 					nrf6350_lcd_write_string(cap1_s[n], 16, LCD_UPPER_LINE, 0);
// 					nrf6350_lcd_write_string("Button 1 to cont", 16, LCD_LOWER_LINE, 0);
// 					nrf_delay_ms(1000);
// 					n++;
// 					if(n >= x)
// 					{
// 						n = 0;
// 					}
// 				}
// 				/* Button 1 to cycle through the different values */ 
// 				/* Button 0 to clear the LCD display */
// 				sw2 = nrf_gpio_pin_read(BUTTON1);
// 				sw = nrf_gpio_pin_read(BUTTON0);
// 			}
		}
	}	
}



/**
 Change Log 
 28/2/2013
 Included the start measurement command
 3/1/2013
 Changed the data extract function to extract the right bits.
 Changed the no of the recieved bit in the read_reg funtion  (i.e from 32 to 24) 
 Changed the decimal place division. 
 3/2/2013
 Fixed the tx_data function in the config reg
 Cleared tx_data using memset.
 3/3/2013
 Cleared rx_data using memset.
 Delay Function before transmssion.
 MSG_LEN is common for both transmit and recieve , the message lengths have been adjusted accordingly
 Debug portion has been commented out.
 implement delayed send of runbit
 3/4/2013
 Implemented parameter registers from 11 to 19
 Transmitting one configregister at a time
 NOTE ****** need to implement tranmsit check in pcap_config_write()
 3/6/2013
 Implemented runbit clearing before config register set
 removed all excess delay 
 reimplemented 32bit config register send
 3/7/2013
 Changing size of transmit and recieve registers from 48-8
 3/8/2013
 Implemented interactive interface on LCD screen and capacitance display based on open ports & configuration
 3/14 - 3/15/2013
 Implemented ANT transmission protocols adopted from broadcast_tx example
 Removed some excess button read commands and flags
 3/18/2013
 Changed memory location on target option to enable ARM IRQ
 Implemented delay to enable read of 2 data packet. 
 3/19/2013
 Removed Delay and implemented acknowledge transmission
 Changed all EVENT_TX to EVENT_TX_COMPLETED
 3/21/2013
 Changed location of Status transmit
 Implemented an extra EVENT_TX case to start loop
 Code seems to work!!
 5/17/2013
 possible error in the program 
 msg_len in pcap_config_write was previoulsy 3 ... value should be 4. 
 5/18/2013
 implemented chk condition on soft exit IF statement to ensure sucessful transmission and prevent infinite looping.
 5/20/2013
 shifted SPI intialisation from within the loop to outside the loop.
 5/22/2013
 in pcapdsp_write changed the declaration of x & regadd to uint16
 change the prg_data to global variable and static
 This works!!!
 6/30/2013
 Implemented changes to ensure PCB compatibility 
 Removed Switch & LCD inputs
 Changed SPI ports
 
 **/
